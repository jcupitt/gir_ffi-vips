##
# call-seq:
#    Vips::Image.system(cmd-format) => 
#
# Run an external command.
#
#    cmd-format      -- Command to run, input gchararray
#
# Options:
#    in              -- Array of input images, input VipsArrayImage
#    in-format       -- Format for input filename, input gchararray
#    out-format      -- Format for output filename, input gchararray
#
# Output options:
#    out             -- Output image, output VipsImage
#    log             -- Command log, output gchararray

##
# call-seq:
#    add(right) => out
#
# Add two images.
#
#    right           -- Right-hand image argument, input VipsImage
#
#    out             -- Output image, output VipsImage

##
# call-seq:
#    subtract(right) => out
#
# Subtract two images.
#
#    right           -- Right-hand image argument, input VipsImage
#
#    out             -- Output image, output VipsImage

##
# call-seq:
#    multiply(right) => out
#
# Multiply two images.
#
#    right           -- Right-hand image argument, input VipsImage
#
#    out             -- Output image, output VipsImage

##
# call-seq:
#    divide(right) => out
#
# Divide two images.
#
#    right           -- Right-hand image argument, input VipsImage
#
#    out             -- Output image, output VipsImage

##
# call-seq:
#    relational(right, relational) => out
#
# Relational operation on two images.
#
#    right           -- Right-hand image argument, input VipsImage
#    relational      -- relational to perform, input VipsOperationRelational
#
#    out             -- Output image, output VipsImage

##
# call-seq:
#    remainder(right) => out
#
# Remainder after integer division of two images.
#
#    right           -- Right-hand image argument, input VipsImage
#
#    out             -- Output image, output VipsImage

##
# call-seq:
#    boolean(right, boolean) => out
#
# Boolean operation on two images.
#
#    right           -- Right-hand image argument, input VipsImage
#    boolean         -- boolean to perform, input VipsOperationBoolean
#
#    out             -- Output image, output VipsImage

##
# call-seq:
#    math2(right, math2) => out
#
# Binary math operations.
#
#    right           -- Right-hand image argument, input VipsImage
#    math2           -- math to perform, input VipsOperationMath2
#
#    out             -- Output image, output VipsImage

##
# call-seq:
#    complex2(right, cmplx) => out
#
# Complex binary operations on two images.
#
#    right           -- Right-hand image argument, input VipsImage
#    cmplx           -- binary complex operation to perform, input VipsOperationComplex2
#
#    out             -- Output image, output VipsImage

##
# call-seq:
#    complexform(right) => out
#
# Form a complex image from two real images.
#
#    right           -- Right-hand image argument, input VipsImage
#
#    out             -- Output image, output VipsImage

##
# call-seq:
#    Vips::Image.sum(in) => out
#
# Sum an array of images.
#
#    in              -- Array of input images, input VipsArrayImage
#
#    out             -- Output image, output VipsImage

##
# call-seq:
#    invert() => out
#
# Invert an image.
#
#    out             -- Output image, output VipsImage

##
# call-seq:
#    linear(a, b) => out
#
# Calculate (a * in + b).
#
#    a               -- Multiply by this, input VipsArrayDouble
#    b               -- Add this, input VipsArrayDouble
#
#    out             -- Output image, output VipsImage
#
# Options:
#    uchar           -- Output should be uchar, input gboolean

##
# call-seq:
#    math(math) => out
#
# Apply a math operation to an image.
#
#    math            -- math to perform, input VipsOperationMath
#
#    out             -- Output image, output VipsImage

##
# call-seq:
#    abs() => out
#
# Absolute value of an image.
#
#    out             -- Output image, output VipsImage

##
# call-seq:
#    sign() => out
#
# Unit vector of pixel.
#
#    out             -- Output image, output VipsImage

##
# call-seq:
#    round(round) => out
#
# Perform a round function on an image.
#
#    round           -- rounding operation to perform, input VipsOperationRound
#
#    out             -- Output image, output VipsImage

##
# call-seq:
#    relational_const(c, relational) => out
#
# Relational operations against a constant.
#
#    c               -- Array of constants, input VipsArrayDouble
#    relational      -- relational to perform, input VipsOperationRelational
#
#    out             -- Output image, output VipsImage

##
# call-seq:
#    remainder_const(c) => out
#
# Remainder after integer division of an image and a constant.
#
#    c               -- Array of constants, input VipsArrayDouble
#
#    out             -- Output image, output VipsImage

##
# call-seq:
#    boolean_const(c, boolean) => out
#
# Boolean operations against a constant.
#
#    c               -- Array of constants, input VipsArrayDouble
#    boolean         -- boolean to perform, input VipsOperationBoolean
#
#    out             -- Output image, output VipsImage

##
# call-seq:
#    math2_const(c, math2) => out
#
# Pow( @in, @c ).
#
#    c               -- Array of constants, input VipsArrayDouble
#    math2           -- math to perform, input VipsOperationMath2
#
#    out             -- Output image, output VipsImage

##
# call-seq:
#    complex(cmplx) => out
#
# Perform a complex operation on an image.
#
#    cmplx           -- complex to perform, input VipsOperationComplex
#
#    out             -- Output image, output VipsImage

##
# call-seq:
#    complexget(get) => out
#
# Get a component from a complex image.
#
#    get             -- complex to perform, input VipsOperationComplexget
#
#    out             -- Output image, output VipsImage

##
# call-seq:
#    avg() => out
#
# Find image average.
#
#    out             -- Output value, output gdouble

##
# call-seq:
#    min() => out
#
# Find image minimum.
#
#    out             -- Output value, output gdouble
#
# Options:
#    size            -- Number of minimum values to find, input gint
#
# Output options:
#    x               -- Horizontal position of minimum, output gint
#    y               -- Vertical position of minimum, output gint
#    out-array       -- Array of output values, output VipsArrayDouble
#    x-array         -- Array of horizontal positions, output VipsArrayInt
#    y-array         -- Array of vertical positions, output VipsArrayInt

##
# call-seq:
#    max() => out
#
# Find image maximum.
#
#    out             -- Output value, output gdouble
#
# Options:
#    size            -- Number of maximum values to find, input gint
#
# Output options:
#    x               -- Horizontal position of maximum, output gint
#    y               -- Vertical position of maximum, output gint
#    out-array       -- Array of output values, output VipsArrayDouble
#    x-array         -- Array of horizontal positions, output VipsArrayInt
#    y-array         -- Array of vertical positions, output VipsArrayInt

##
# call-seq:
#    deviate() => out
#
# Find image standard deviation.
#
#    out             -- Output value, output gdouble

##
# call-seq:
#    stats() => out
#
# Find image average.
#
#    out             -- Output array of statistics, output VipsImage

##
# call-seq:
#    hist_find() => out
#
# Find image histogram.
#
#    out             -- Output histogram, output VipsImage
#
# Options:
#    band            -- Find histogram of band, input gint

##
# call-seq:
#    hist_find_ndim() => out
#
# Find n-dimensional image histogram.
#
#    out             -- Output histogram, output VipsImage
#
# Options:
#    bins            -- Number of bins in each dimension, input gint

##
# call-seq:
#    hist_find_indexed(index) => out
#
# Find indexed image histogram.
#
#    index           -- Index image, input VipsImage
#
#    out             -- Output histogram, output VipsImage

##
# call-seq:
#    hough_line() => out
#
# Find hough line transform.
#
#    out             -- Output image, output VipsImage
#
# Options:
#    width           -- horizontal size of parameter space, input gint
#    height          -- Vertical size of parameter space, input gint

##
# call-seq:
#    hough_circle() => out
#
# Find hough circle transform.
#
#    out             -- Output image, output VipsImage
#
# Options:
#    scale           -- Scale down dimensions by this factor, input gint
#    min-radius      -- Smallest radius to search for, input gint
#    max-radius      -- Largest radius to search for, input gint

##
# call-seq:
#    project() => columns, rows
#
# Find image projections.
#
#    columns         -- Sums of columns, output VipsImage
#    rows            -- Sums of rows, output VipsImage

##
# call-seq:
#    profile() => columns, rows
#
# Find image profiles.
#
#    columns         -- First non-zero pixel in column, output VipsImage
#    rows            -- First non-zero pixel in row, output VipsImage

##
# call-seq:
#    measure(h, v) => out
#
# Measure a set of patches on a color chart.
#
#    h               -- Number of patches across chart, input gint
#    v               -- Number of patches down chart, input gint
#
#    out             -- Output array of statistics, output VipsImage
#
# Options:
#    left            -- Left edge of extract area, input gint
#    top             -- Top edge of extract area, input gint
#    width           -- Width of extract area, input gint
#    height          -- Height of extract area, input gint

##
# call-seq:
#    getpoint(x, y) => out-array
#
# Read a point from an image.
#
#    x               -- Point to read, input gint
#    y               -- Point to read, input gint
#
#    out-array       -- Array of output values, output VipsArrayDouble

##
# call-seq:
#    copy() => out
#
# Copy an image.
#
#    out             -- Output image, output VipsImage
#
# Options:
#    swap            -- Swap bytes in image between little and big-endian, input gboolean
#    width           -- Image width in pixels, input gint
#    height          -- Image height in pixels, input gint
#    bands           -- Number of bands in image, input gint
#    format          -- Pixel format in image, input VipsBandFormat
#    coding          -- Pixel coding, input VipsCoding
#    interpretation  -- Pixel interpretation, input VipsInterpretation
#    xres            -- Horizontal resolution in pixels/mm, input gdouble
#    yres            -- Vertical resolution in pixels/mm, input gdouble
#    xoffset         -- Horizontal offset of origin, input gint
#    yoffset         -- Vertical offset of origin, input gint

##
# call-seq:
#    blockcache() => out
#
# Cache an image.
#
#    out             -- Output image, output VipsImage
#
# Options:
#    tile-height     -- Tile height in pixels, input gint
#    access          -- Expected access pattern, input VipsAccess
#    threaded        -- Allow threaded access, input gboolean
#    persistent      -- Keep cache between evaluations, input gboolean

##
# call-seq:
#    tilecache() => out
#
# Cache an image as a set of tiles.
#
#    out             -- Output image, output VipsImage
#
# Options:
#    tile-width      -- Tile width in pixels, input gint
#    tile-height     -- Tile height in pixels, input gint
#    max-tiles       -- Maximum number of tiles to cache, input gint
#    access          -- Expected access pattern, input VipsAccess
#    threaded        -- Allow threaded access, input gboolean
#    persistent      -- Keep cache between evaluations, input gboolean

##
# call-seq:
#    linecache() => out
#
# Cache an image as a set of lines.
#
#    out             -- Output image, output VipsImage
#
# Options:
#    tile-height     -- Tile height in pixels, input gint
#    access          -- Expected access pattern, input VipsAccess
#    threaded        -- Allow threaded access, input gboolean
#    persistent      -- Keep cache between evaluations, input gboolean

##
# call-seq:
#    sequential() => out
#
# Check sequential access.
#
#    out             -- Output image, output VipsImage
#
# Options:
#    trace           -- trace pixel requests, input gboolean
#    tile-height     -- Tile height in pixels, input gint
#    access          -- Expected access pattern, input VipsAccess

##
# call-seq:
#    cache() => out
#
# Cache an image.
#
#    out             -- Output image, output VipsImage
#
# Options:
#    tile-width      -- Tile width in pixels, input gint
#    tile-height     -- Tile height in pixels, input gint
#    max-tiles       -- Maximum number of tiles to cache, input gint

##
# call-seq:
#    embed(x, y, width, height) => out
#
# Embed an image in a larger image.
#
#    x               -- Left edge of input in output, input gint
#    y               -- Top edge of input in output, input gint
#    width           -- Image width in pixels, input gint
#    height          -- Image height in pixels, input gint
#
#    out             -- Output image, output VipsImage
#
# Options:
#    extend          -- How to generate the extra pixels, input VipsExtend
#    background      -- Colour for background pixels, input VipsArrayDouble

##
# call-seq:
#    flip(direction) => out
#
# Flip an image.
#
#    direction       -- Direction to flip image, input VipsDirection
#
#    out             -- Output image, output VipsImage

##
# call-seq:
#    insert(sub, x, y) => out
#
# Insert image @sub into @main at @x, @y.
#
#    sub             -- Sub-image to insert into main image, input VipsImage
#    x               -- Left edge of sub in main, input gint
#    y               -- Top edge of sub in main, input gint
#
#    out             -- Output image, output VipsImage
#
# Options:
#    expand          -- Expand output to hold all of both inputs, input gboolean
#    background      -- Colour for new pixels, input VipsArrayDouble

##
# call-seq:
#    join(in2, direction) => out
#
# Join a pair of images.
#
#    in2             -- Second input image, input VipsImage
#    direction       -- Join left-right or up-down, input VipsDirection
#
#    out             -- Output image, output VipsImage
#
# Options:
#    align           -- Align on the low, centre or high coordinate edge, input VipsAlign
#    expand          -- Expand output to hold all of both inputs, input gboolean
#    shim            -- Pixels between images, input gint
#    background      -- Colour for new pixels, input VipsArrayDouble

##
# call-seq:
#    extract_area(left, top, width, height) => out
#
# Extract an area from an image.
#
#    left            -- Left edge of extract area, input gint
#    top             -- Top edge of extract area, input gint
#    width           -- Width of extract area, input gint
#    height          -- Height of extract area, input gint
#
#    out             -- Output image, output VipsImage

##
# call-seq:
#    extract_area(left, top, width, height) => out
#
# Extract an area from an image.
#
#    left            -- Left edge of extract area, input gint
#    top             -- Top edge of extract area, input gint
#    width           -- Width of extract area, input gint
#    height          -- Height of extract area, input gint
#
#    out             -- Output image, output VipsImage

##
# call-seq:
#    extract_band(band) => out
#
# Extract band from an image.
#
#    band            -- Band to extract, input gint
#
#    out             -- Output image, output VipsImage
#
# Options:
#    n               -- Number of bands to extract, input gint

##
# call-seq:
#    Vips::Image.bandjoin(in) => out
#
# Bandwise join a set of images.
#
#    in              -- Array of input images, input VipsArrayImage
#
#    out             -- Output image, output VipsImage

##
# call-seq:
#    Vips::Image.bandrank(in) => out
#
# Band-wise rank of a set of images.
#
#    in              -- Array of input images, input VipsArrayImage
#
#    out             -- Output image, output VipsImage
#
# Options:
#    index           -- Select this band element from sorted list, input gint

##
# call-seq:
#    bandmean() => out
#
# Band-wise average.
#
#    out             -- Output image, output VipsImage

##
# call-seq:
#    bandbool(boolean) => out
#
# Boolean operation across image bands.
#
#    boolean         -- boolean to perform, input VipsOperationBoolean
#
#    out             -- Output image, output VipsImage

##
# call-seq:
#    replicate(across, down) => out
#
# Replicate an image.
#
#    across          -- Repeat this many times horizontally, input gint
#    down            -- Repeat this many times vertically, input gint
#
#    out             -- Output image, output VipsImage

##
# call-seq:
#    cast(format) => out
#
# Cast an image.
#
#    format          -- Format to cast to, input VipsBandFormat
#
#    out             -- Output image, output VipsImage

##
# call-seq:
#    rot(angle) => out
#
# Rotate an image.
#
#    angle           -- Angle to rotate image, input VipsAngle
#
#    out             -- Output image, output VipsImage

##
# call-seq:
#    rot45() => out
#
# Rotate an image.
#
#    out             -- Output image, output VipsImage
#
# Options:
#    angle           -- Angle to rotate image, input VipsAngle45

##
# call-seq:
#    autorot() => out
#
# Autorotate image by exif tag.
#
#    out             -- Output image, output VipsImage
#
# Output options:
#    angle           -- Angle image was rotated by, output VipsAngle

##
# call-seq:
#    ifthenelse(in1, in2) => out
#
# Ifthenelse an image.
#
#    in1             -- Source for TRUE pixels, input VipsImage
#    in2             -- Source for FALSE pixels, input VipsImage
#
#    out             -- Output image, output VipsImage
#
# Options:
#    blend           -- Blend smoothly between then and else parts, input gboolean

##
# call-seq:
#    recomb(m) => out
#
# Linear recombination with matrix.
#
#    m               -- matrix of coefficients, input VipsImage
#
#    out             -- Output image, output VipsImage

##
# call-seq:
#    flatten() => out
#
# Flatten alpha out of an image.
#
#    out             -- Output image, output VipsImage
#
# Options:
#    background      -- Background value, input VipsArrayDouble

##
# call-seq:
#    grid(tile-height, across, down) => out
#
# Grid an image.
#
#    tile-height     -- chop into tiles this high, input gint
#    across          -- number of tiles across, input gint
#    down            -- number of tiles down, input gint
#
#    out             -- Output image, output VipsImage

##
# call-seq:
#    scale() => out
#
# Scale an image to uchar.
#
#    out             -- Output image, output VipsImage
#
# Options:
#    log             -- Log scale, input gboolean
#    exp             -- Exponent for log scale, input gdouble

##
# call-seq:
#    wrap() => out
#
# Wrap image origin.
#
#    out             -- Output image, output VipsImage
#
# Options:
#    x               -- Left edge of input in output, input gint
#    y               -- Top edge of input in output, input gint

##
# call-seq:
#    zoom(xfac, yfac) => out
#
# Zoom an image.
#
#    xfac            -- Horizontal zoom factor, input gint
#    yfac            -- Vertical zoom factor, input gint
#
#    out             -- Output image, output VipsImage

##
# call-seq:
#    subsample(xfac, yfac) => out
#
# Subsample an image.
#
#    xfac            -- Horizontal subsample factor, input gint
#    yfac            -- Vertical subsample factor, input gint
#
#    out             -- Output image, output VipsImage
#
# Options:
#    point           -- Point sample, input gboolean

##
# call-seq:
#    msb() => out
#
# Pick most-significant byte from an image.
#
#    out             -- Output image, output VipsImage
#
# Options:
#    band            -- Band to msb, input gint

##
# call-seq:
#    falsecolour() => out
#
# False colour an image.
#
#    out             -- Output image, output VipsImage

##
# call-seq:
#    gamma() => out
#
# Gamma an image.
#
#    out             -- Output image, output VipsImage
#
# Options:
#    exponent        -- Gamma factor, input gdouble

##
# call-seq:
#    Vips::Image.black(width, height) => out
#
# Make a black image.
#
#    width           -- Image width in pixels, input gint
#    height          -- Image height in pixels, input gint
#
#    out             -- Output image, output VipsImage
#
# Options:
#    bands           -- Number of bands in image, input gint

##
# call-seq:
#    Vips::Image.gaussnoise(width, height) => out
#
# Make a gaussnoise image.
#
#    width           -- Image width in pixels, input gint
#    height          -- Image height in pixels, input gint
#
#    out             -- Output image, output VipsImage
#
# Options:
#    mean            -- Mean of pixels in generated image, input gdouble
#    sigma           -- Standard deviation of pixels in generated image, input gdouble

##
# call-seq:
#    Vips::Image.text(text) => out
#
# Make a text image.
#
#    text            -- Text to render, input gchararray
#
#    out             -- Output image, output VipsImage
#
# Options:
#    width           -- Maximum image width in pixels, input gint
#    font            -- Font to render width, input gchararray
#    dpi             -- DPI to render at, input gint
#    align           -- Align on the low, centre or high coordinate edge, input VipsAlign

##
# call-seq:
#    Vips::Image.xyz(width, height) => out
#
# Make an image where pixel values are coordinates.
#
#    width           -- Image width in pixels, input gint
#    height          -- Image height in pixels, input gint
#
#    out             -- Output image, output VipsImage
#
# Options:
#    csize           -- Size of third dimension, input gint
#    dsize           -- Size of fourth dimension, input gint
#    esize           -- Size of fifth dimension, input gint

##
# call-seq:
#    Vips::Image.gaussmat(sigma, min-ampl) => out
#
# Make a gaussian image.
#
#    sigma           -- Sigma of Gaussian, input gdouble
#    min-ampl        -- Minimum amplitude of Gaussian, input gdouble
#
#    out             -- Output image, output VipsImage
#
# Options:
#    separable       -- Generate separable Gaussian, input gboolean
#    integer         -- Generate integer Gaussian, input gboolean

##
# call-seq:
#    Vips::Image.logmat(sigma, min-ampl) => out
#
# Make a laplacian of gaussian image.
#
#    sigma           -- Radius of Logmatian, input gdouble
#    min-ampl        -- Minimum amplitude of Logmatian, input gdouble
#
#    out             -- Output image, output VipsImage
#
# Options:
#    separable       -- Generate separable Logmatian, input gboolean
#    integer         -- Generate integer Logmatian, input gboolean

##
# call-seq:
#    Vips::Image.eye(width, height) => out
#
# Make an image showing the eye's spatial response.
#
#    width           -- Image width in pixels, input gint
#    height          -- Image height in pixels, input gint
#
#    out             -- Output image, output VipsImage
#
# Options:
#    uchar           -- Output an unsigned char image, input gboolean
#    factor          -- Maximum spatial frequency, input gdouble

##
# call-seq:
#    Vips::Image.grey(width, height) => out
#
# Make a grey ramp image.
#
#    width           -- Image width in pixels, input gint
#    height          -- Image height in pixels, input gint
#
#    out             -- Output image, output VipsImage
#
# Options:
#    uchar           -- Output an unsigned char image, input gboolean

##
# call-seq:
#    Vips::Image.zone(width, height) => out
#
# Make a zone plate.
#
#    width           -- Image width in pixels, input gint
#    height          -- Image height in pixels, input gint
#
#    out             -- Output image, output VipsImage
#
# Options:
#    uchar           -- Output an unsigned char image, input gboolean

##
# call-seq:
#    Vips::Image.sines(width, height) => out
#
# Make a 2d sine wave.
#
#    width           -- Image width in pixels, input gint
#    height          -- Image height in pixels, input gint
#
#    out             -- Output image, output VipsImage
#
# Options:
#    uchar           -- Output an unsigned char image, input gboolean
#    hfreq           -- Horizontal spatial frequency, input gdouble
#    vfreq           -- Vertical spatial frequency, input gdouble

##
# call-seq:
#    Vips::Image.mask_ideal(width, height, frequency-cutoff) => out
#
# Make an ideal filter.
#
#    width           -- Image width in pixels, input gint
#    height          -- Image height in pixels, input gint
#    frequency-cutoff -- Frequency cutoff, input gdouble
#
#    out             -- Output image, output VipsImage
#
# Options:
#    uchar           -- Output an unsigned char image, input gboolean
#    nodc            -- Remove DC component, input gboolean
#    reject          -- Invert the sense of the filter, input gboolean
#    optical         -- Rotate quadrants to optical space, input gboolean

##
# call-seq:
#    Vips::Image.mask_ideal_ring(width, height, frequency-cutoff, ringwidth) => out
#
# Make an ideal ring filter.
#
#    width           -- Image width in pixels, input gint
#    height          -- Image height in pixels, input gint
#    frequency-cutoff -- Frequency cutoff, input gdouble
#    ringwidth       -- Ringwidth, input gdouble
#
#    out             -- Output image, output VipsImage
#
# Options:
#    uchar           -- Output an unsigned char image, input gboolean
#    nodc            -- Remove DC component, input gboolean
#    reject          -- Invert the sense of the filter, input gboolean
#    optical         -- Rotate quadrants to optical space, input gboolean

##
# call-seq:
#    Vips::Image.mask_ideal_band(width, height, frequency-cutoff-x, frequency-cutoff-y, radius) => out
#
# Make an ideal band filter.
#
#    width           -- Image width in pixels, input gint
#    height          -- Image height in pixels, input gint
#    frequency-cutoff-x -- Frequency cutoff x, input gdouble
#    frequency-cutoff-y -- Frequency cutoff y, input gdouble
#    radius          -- radius of circle, input gdouble
#
#    out             -- Output image, output VipsImage
#
# Options:
#    uchar           -- Output an unsigned char image, input gboolean
#    optical         -- Rotate quadrants to optical space, input gboolean
#    nodc            -- Remove DC component, input gboolean
#    reject          -- Invert the sense of the filter, input gboolean

##
# call-seq:
#    Vips::Image.mask_butterworth(width, height, order, frequency-cutoff, amplitude-cutoff) => out
#
# Make a butterworth filter.
#
#    width           -- Image width in pixels, input gint
#    height          -- Image height in pixels, input gint
#    order           -- Filter order, input gdouble
#    frequency-cutoff -- Frequency cutoff, input gdouble
#    amplitude-cutoff -- Amplitude cutoff, input gdouble
#
#    out             -- Output image, output VipsImage
#
# Options:
#    uchar           -- Output an unsigned char image, input gboolean
#    optical         -- Rotate quadrants to optical space, input gboolean
#    nodc            -- Remove DC component, input gboolean
#    reject          -- Invert the sense of the filter, input gboolean

##
# call-seq:
#    Vips::Image.mask_butterworth_ring(width, height, order, frequency-cutoff, amplitude-cutoff, ringwidth) => out
#
# Make a butterworth ring filter.
#
#    width           -- Image width in pixels, input gint
#    height          -- Image height in pixels, input gint
#    order           -- Filter order, input gdouble
#    frequency-cutoff -- Frequency cutoff, input gdouble
#    amplitude-cutoff -- Amplitude cutoff, input gdouble
#    ringwidth       -- Ringwidth, input gdouble
#
#    out             -- Output image, output VipsImage
#
# Options:
#    uchar           -- Output an unsigned char image, input gboolean
#    optical         -- Rotate quadrants to optical space, input gboolean
#    nodc            -- Remove DC component, input gboolean
#    reject          -- Invert the sense of the filter, input gboolean

##
# call-seq:
#    Vips::Image.mask_butterworth_band(width, height, order, frequency-cutoff-x, frequency-cutoff-y, radius, amplitude-cutoff) => out
#
# Make a butterworth_band filter.
#
#    width           -- Image width in pixels, input gint
#    height          -- Image height in pixels, input gint
#    order           -- Filter order, input gdouble
#    frequency-cutoff-x -- Frequency cutoff x, input gdouble
#    frequency-cutoff-y -- Frequency cutoff y, input gdouble
#    radius          -- radius of circle, input gdouble
#    amplitude-cutoff -- Amplitude cutoff, input gdouble
#
#    out             -- Output image, output VipsImage
#
# Options:
#    uchar           -- Output an unsigned char image, input gboolean
#    optical         -- Rotate quadrants to optical space, input gboolean
#    reject          -- Invert the sense of the filter, input gboolean
#    nodc            -- Remove DC component, input gboolean

##
# call-seq:
#    Vips::Image.mask_gaussian(width, height, frequency-cutoff, amplitude-cutoff) => out
#
# Make a gaussian filter.
#
#    width           -- Image width in pixels, input gint
#    height          -- Image height in pixels, input gint
#    frequency-cutoff -- Frequency cutoff, input gdouble
#    amplitude-cutoff -- Amplitude cutoff, input gdouble
#
#    out             -- Output image, output VipsImage
#
# Options:
#    uchar           -- Output an unsigned char image, input gboolean
#    nodc            -- Remove DC component, input gboolean
#    reject          -- Invert the sense of the filter, input gboolean
#    optical         -- Rotate quadrants to optical space, input gboolean

##
# call-seq:
#    Vips::Image.mask_gaussian_ring(width, height, frequency-cutoff, amplitude-cutoff, ringwidth) => out
#
# Make a gaussian ring filter.
#
#    width           -- Image width in pixels, input gint
#    height          -- Image height in pixels, input gint
#    frequency-cutoff -- Frequency cutoff, input gdouble
#    amplitude-cutoff -- Amplitude cutoff, input gdouble
#    ringwidth       -- Ringwidth, input gdouble
#
#    out             -- Output image, output VipsImage
#
# Options:
#    uchar           -- Output an unsigned char image, input gboolean
#    optical         -- Rotate quadrants to optical space, input gboolean
#    nodc            -- Remove DC component, input gboolean
#    reject          -- Invert the sense of the filter, input gboolean

##
# call-seq:
#    Vips::Image.mask_gaussian_band(width, height, frequency-cutoff-x, frequency-cutoff-y, radius, amplitude-cutoff) => out
#
# Make a gaussian filter.
#
#    width           -- Image width in pixels, input gint
#    height          -- Image height in pixels, input gint
#    frequency-cutoff-x -- Frequency cutoff x, input gdouble
#    frequency-cutoff-y -- Frequency cutoff y, input gdouble
#    radius          -- radius of circle, input gdouble
#    amplitude-cutoff -- Amplitude cutoff, input gdouble
#
#    out             -- Output image, output VipsImage
#
# Options:
#    uchar           -- Output an unsigned char image, input gboolean
#    optical         -- Rotate quadrants to optical space, input gboolean
#    nodc            -- Remove DC component, input gboolean
#    reject          -- Invert the sense of the filter, input gboolean

##
# call-seq:
#    Vips::Image.mask_fractal(width, height, fractal-dimension) => out
#
# Make fractal filter.
#
#    width           -- Image width in pixels, input gint
#    height          -- Image height in pixels, input gint
#    fractal-dimension -- Fractal dimension, input gdouble
#
#    out             -- Output image, output VipsImage
#
# Options:
#    uchar           -- Output an unsigned char image, input gboolean
#    nodc            -- Remove DC component, input gboolean
#    reject          -- Invert the sense of the filter, input gboolean
#    optical         -- Rotate quadrants to optical space, input gboolean

##
# call-seq:
#    buildlut() => out
#
# Build a look-up table.
#
#    out             -- Output image, output VipsImage

##
# call-seq:
#    invertlut() => out
#
# Build an inverted look-up table.
#
#    out             -- Output image, output VipsImage
#
# Options:
#    size            -- LUT size to generate, input gint

##
# call-seq:
#    Vips::Image.tonelut() => out
#
# Build a look-up table.
#
#    out             -- Output image, output VipsImage
#
# Options:
#    in-max          -- Size of LUT to build, input gint
#    out-max         -- Maximum value in output LUT, input gint
#    Lb              -- Lowest value in output, input gdouble
#    Lw              -- Highest value in output, input gdouble
#    Ps              -- Position of shadow, input gdouble
#    Pm              -- Position of mid-tones, input gdouble
#    Ph              -- Position of highlights, input gdouble
#    S               -- Adjust shadows by this much, input gdouble
#    M               -- Adjust mid-tones by this much, input gdouble
#    H               -- Adjust highlights by this much, input gdouble

##
# call-seq:
#    Vips::Image.identity() => out
#
# Make a 1d image where pixel values are indexes.
#
#    out             -- Output image, output VipsImage
#
# Options:
#    bands           -- Number of bands in LUT, input gint
#    ushort          -- Create a 16-bit LUT, input gboolean
#    size            -- Size of 16-bit LUT, input gint

##
# call-seq:
#    Vips::Image.fractsurf(width, height, fractal-dimension) => out
#
# Make a fractal surface.
#
#    width           -- Image width in pixels, input gint
#    height          -- Image height in pixels, input gint
#    fractal-dimension -- Fractal dimension, input gdouble
#
#    out             -- Output image, output VipsImage

##
# call-seq:
#    Vips::Image.radload(filename) => out
#
# Load a radiance image from a file.
#
#    filename        -- Filename to load from, input gchararray
#
#    out             -- Output image, output VipsImage
#
# Options:
#    disc            -- Open to disc, input gboolean
#    access          -- Required access pattern for this file, input VipsAccess
#
# Output options:
#    flags           -- Flags for this file, output VipsForeignFlags

##
# call-seq:
#    Vips::Image.ppmload(filename) => out
#
# Load ppm from file.
#
#    filename        -- Filename to load from, input gchararray
#
#    out             -- Output image, output VipsImage
#
# Options:
#    disc            -- Open to disc, input gboolean
#    access          -- Required access pattern for this file, input VipsAccess
#
# Output options:
#    flags           -- Flags for this file, output VipsForeignFlags

##
# call-seq:
#    Vips::Image.csvload(filename) => out
#
# Load csv from file.
#
#    filename        -- Filename to load from, input gchararray
#
#    out             -- Output image, output VipsImage
#
# Options:
#    disc            -- Open to disc, input gboolean
#    access          -- Required access pattern for this file, input VipsAccess
#    skip            -- Skip this many lines at the start of the file, input gint
#    lines           -- Read this many lines from the file, input gint
#    whitespace      -- Set of whitespace characters, input gchararray
#    separator       -- Set of separator characters, input gchararray
#
# Output options:
#    flags           -- Flags for this file, output VipsForeignFlags

##
# call-seq:
#    Vips::Image.matrixload(filename) => out
#
# Load matrix from file.
#
#    filename        -- Filename to load from, input gchararray
#
#    out             -- Output image, output VipsImage
#
# Options:
#    disc            -- Open to disc, input gboolean
#    access          -- Required access pattern for this file, input VipsAccess
#
# Output options:
#    flags           -- Flags for this file, output VipsForeignFlags

##
# call-seq:
#    Vips::Image.analyzeload(filename) => out
#
# Load an analyze6 image.
#
#    filename        -- Filename to load from, input gchararray
#
#    out             -- Output image, output VipsImage
#
# Options:
#    disc            -- Open to disc, input gboolean
#    access          -- Required access pattern for this file, input VipsAccess
#
# Output options:
#    flags           -- Flags for this file, output VipsForeignFlags

##
# call-seq:
#    Vips::Image.rawload(filename, width, height, bands) => out
#
# Load raw data from a file.
#
#    filename        -- Filename to load from, input gchararray
#    width           -- Image width in pixels, input gint
#    height          -- Image height in pixels, input gint
#    bands           -- Number of bands in image, input gint
#
#    out             -- Output image, output VipsImage
#
# Options:
#    disc            -- Open to disc, input gboolean
#    access          -- Required access pattern for this file, input VipsAccess
#    offset          -- Offset in bytes from start of file, input guint64
#
# Output options:
#    flags           -- Flags for this file, output VipsForeignFlags

##
# call-seq:
#    Vips::Image.vipsload(filename) => out
#
# Load vips from file.
#
#    filename        -- Filename to load from, input gchararray
#
#    out             -- Output image, output VipsImage
#
# Options:
#    disc            -- Open to disc, input gboolean
#    access          -- Required access pattern for this file, input VipsAccess
#
# Output options:
#    flags           -- Flags for this file, output VipsForeignFlags

##
# call-seq:
#    Vips::Image.pngload(filename) => out
#
# Load png from file.
#
#    filename        -- Filename to load from, input gchararray
#
#    out             -- Output image, output VipsImage
#
# Options:
#    disc            -- Open to disc, input gboolean
#    access          -- Required access pattern for this file, input VipsAccess
#
# Output options:
#    flags           -- Flags for this file, output VipsForeignFlags

##
# call-seq:
#    Vips::Image.pngload_buffer(buffer) => out
#
# Load png from buffer.
#
#    buffer          -- Buffer to load from, input VipsBlob
#
#    out             -- Output image, output VipsImage
#
# Options:
#    disc            -- Open to disc, input gboolean
#    access          -- Required access pattern for this file, input VipsAccess
#
# Output options:
#    flags           -- Flags for this file, output VipsForeignFlags

##
# call-seq:
#    Vips::Image.matload(filename) => out
#
# Load mat from file.
#
#    filename        -- Filename to load from, input gchararray
#
#    out             -- Output image, output VipsImage
#
# Options:
#    disc            -- Open to disc, input gboolean
#    access          -- Required access pattern for this file, input VipsAccess
#
# Output options:
#    flags           -- Flags for this file, output VipsForeignFlags

##
# call-seq:
#    Vips::Image.jpegload(filename) => out
#
# Load jpeg from file.
#
#    filename        -- Filename to load from, input gchararray
#
#    out             -- Output image, output VipsImage
#
# Options:
#    disc            -- Open to disc, input gboolean
#    access          -- Required access pattern for this file, input VipsAccess
#    shrink          -- Shrink factor on load, input gint
#    fail            -- Fail on first warning, input gboolean
#    autorotate      -- Automatically rotate image using exif orientation, input gboolean
#
# Output options:
#    flags           -- Flags for this file, output VipsForeignFlags

##
# call-seq:
#    Vips::Image.jpegload_buffer(buffer) => out
#
# Load jpeg from buffer.
#
#    buffer          -- Buffer to load from, input VipsBlob
#
#    out             -- Output image, output VipsImage
#
# Options:
#    disc            -- Open to disc, input gboolean
#    access          -- Required access pattern for this file, input VipsAccess
#    shrink          -- Shrink factor on load, input gint
#    fail            -- Fail on first warning, input gboolean
#    autorotate      -- Automatically rotate image using exif orientation, input gboolean
#
# Output options:
#    flags           -- Flags for this file, output VipsForeignFlags

##
# call-seq:
#    Vips::Image.webpload(filename) => out
#
# Load webp from file.
#
#    filename        -- Filename to load from, input gchararray
#
#    out             -- Output image, output VipsImage
#
# Options:
#    disc            -- Open to disc, input gboolean
#    access          -- Required access pattern for this file, input VipsAccess
#
# Output options:
#    flags           -- Flags for this file, output VipsForeignFlags

##
# call-seq:
#    Vips::Image.webpload_buffer(buffer) => out
#
# Load webp from buffer.
#
#    buffer          -- Buffer to load from, input VipsBlob
#
#    out             -- Output image, output VipsImage
#
# Options:
#    disc            -- Open to disc, input gboolean
#    access          -- Required access pattern for this file, input VipsAccess
#
# Output options:
#    flags           -- Flags for this file, output VipsForeignFlags

##
# call-seq:
#    Vips::Image.tiffload(filename) => out
#
# Load tiff from file.
#
#    filename        -- Filename to load from, input gchararray
#
#    out             -- Output image, output VipsImage
#
# Options:
#    disc            -- Open to disc, input gboolean
#    access          -- Required access pattern for this file, input VipsAccess
#    page            -- Load this page from the image, input gint
#
# Output options:
#    flags           -- Flags for this file, output VipsForeignFlags

##
# call-seq:
#    Vips::Image.tiffload_buffer(buffer) => out
#
# Load tiff from buffer.
#
#    buffer          -- Buffer to load from, input VipsBlob
#
#    out             -- Output image, output VipsImage
#
# Options:
#    disc            -- Open to disc, input gboolean
#    access          -- Required access pattern for this file, input VipsAccess
#    page            -- Load this page from the image, input gint
#
# Output options:
#    flags           -- Flags for this file, output VipsForeignFlags

##
# call-seq:
#    Vips::Image.openslideload(filename) => out
#
# Load file with openslide.
#
#    filename        -- Filename to load from, input gchararray
#
#    out             -- Output image, output VipsImage
#
# Options:
#    disc            -- Open to disc, input gboolean
#    access          -- Required access pattern for this file, input VipsAccess
#    level           -- Load this level from the file, input gint
#    autocrop        -- Crop to image bounds, input gboolean
#    associated      -- Load this associated image, input gchararray
#
# Output options:
#    flags           -- Flags for this file, output VipsForeignFlags

##
# call-seq:
#    Vips::Image.magickload(filename) => out
#
# Load file with imagemagick.
#
#    filename        -- Filename to load from, input gchararray
#
#    out             -- Output image, output VipsImage
#
# Options:
#    all-frames      -- Read all frames from an image, input gboolean
#    density         -- Canvas resolution for rendering vector formats like SVG, input gchararray
#    disc            -- Open to disc, input gboolean
#    access          -- Required access pattern for this file, input VipsAccess
#
# Output options:
#    flags           -- Flags for this file, output VipsForeignFlags

##
# call-seq:
#    Vips::Image.fitsload(filename) => out
#
# Load a fits image.
#
#    filename        -- Filename to load from, input gchararray
#
#    out             -- Output image, output VipsImage
#
# Options:
#    disc            -- Open to disc, input gboolean
#    access          -- Required access pattern for this file, input VipsAccess
#
# Output options:
#    flags           -- Flags for this file, output VipsForeignFlags

##
# call-seq:
#    Vips::Image.openexrload(filename) => out
#
# Load an openexr image.
#
#    filename        -- Filename to load from, input gchararray
#
#    out             -- Output image, output VipsImage
#
# Options:
#    disc            -- Open to disc, input gboolean
#    access          -- Required access pattern for this file, input VipsAccess
#
# Output options:
#    flags           -- Flags for this file, output VipsForeignFlags

##
# call-seq:
#    radsave(filename) => 
#
# Save image to radiance file.
#
#    filename        -- Filename to save to, input gchararray
#
# Options:
#    strip           -- Strip all metadata from image, input gboolean
#    background      -- Background value, input VipsArrayDouble

##
# call-seq:
#    ppmsave(filename) => 
#
# Save image to ppm file.
#
#    filename        -- Filename to save to, input gchararray
#
# Options:
#    ascii           -- save as ascii, input gboolean
#    squash          -- save as one bit, input gboolean
#    strip           -- Strip all metadata from image, input gboolean
#    background      -- Background value, input VipsArrayDouble

##
# call-seq:
#    csvsave(filename) => 
#
# Save image to csv file.
#
#    filename        -- Filename to save to, input gchararray
#
# Options:
#    separator       -- Separator characters, input gchararray
#    strip           -- Strip all metadata from image, input gboolean
#    background      -- Background value, input VipsArrayDouble

##
# call-seq:
#    matrixsave(filename) => 
#
# Save image to matrix file.
#
#    filename        -- Filename to save to, input gchararray
#
# Options:
#    strip           -- Strip all metadata from image, input gboolean
#    background      -- Background value, input VipsArrayDouble

##
# call-seq:
#    matrixprint() => 
#
# Print matrix.
#
# Options:
#    strip           -- Strip all metadata from image, input gboolean
#    background      -- Background value, input VipsArrayDouble

##
# call-seq:
#    rawsave(filename) => 
#
# Save image to raw file.
#
#    filename        -- Filename to save to, input gchararray
#
# Options:
#    strip           -- Strip all metadata from image, input gboolean
#    background      -- Background value, input VipsArrayDouble

##
# call-seq:
#    rawsave_fd(fd) => 
#
# Write raw image to file descriptor.
#
#    fd              -- File descriptor to write to, input gint
#
# Options:
#    strip           -- Strip all metadata from image, input gboolean
#    background      -- Background value, input VipsArrayDouble

##
# call-seq:
#    vipssave(filename) => 
#
# Save image to vips file.
#
#    filename        -- Filename to save to, input gchararray
#
# Options:
#    strip           -- Strip all metadata from image, input gboolean
#    background      -- Background value, input VipsArrayDouble

##
# call-seq:
#    dzsave(filename) => 
#
# Save image to deep zoom format.
#
#    filename        -- Filename to save to, input gchararray
#
# Options:
#    layout          -- Directory layout, input VipsForeignDzLayout
#    suffix          -- Filename suffix for tiles, input gchararray
#    overlap         -- Tile overlap in pixels, input gint
#    tile-size       -- Tile size in pixels, input gint
#    background      -- Colour for background pixels, input VipsArrayDouble
#    centre          -- Center image in tile, input gboolean
#    depth           -- Pyramid depth, input VipsForeignDzDepth
#    angle           -- Rotate image during save, input VipsAngle
#    container       -- Pyramid container type, input VipsForeignDzContainer
#    properties      -- Write a properties file to the output directory, input gboolean
#    strip           -- Strip all metadata from image, input gboolean

##
# call-seq:
#    pngsave(filename) => 
#
# Save image to png file.
#
#    filename        -- Filename to save to, input gchararray
#
# Options:
#    compression     -- Compression factor, input gint
#    interlace       -- Interlace image, input gboolean
#    profile         -- ICC profile to embed, input gchararray
#    filter          -- libpng row filter flag(s), input VipsForeignPngFilter
#    strip           -- Strip all metadata from image, input gboolean
#    background      -- Background value, input VipsArrayDouble

##
# call-seq:
#    pngsave_buffer() => buffer
#
# Save image to png buffer.
#
#    buffer          -- Buffer to save to, output VipsBlob
#
# Options:
#    compression     -- Compression factor, input gint
#    interlace       -- Interlace image, input gboolean
#    profile         -- ICC profile to embed, input gchararray
#    filter          -- libpng row filter flag(s), input VipsForeignPngFilter
#    strip           -- Strip all metadata from image, input gboolean
#    background      -- Background value, input VipsArrayDouble

##
# call-seq:
#    jpegsave(filename) => 
#
# Save image to jpeg file.
#
#    filename        -- Filename to save to, input gchararray
#
# Options:
#    Q               -- Q factor, input gint
#    profile         -- ICC profile to embed, input gchararray
#    optimize-coding -- Compute optimal Huffman coding tables, input gboolean
#    interlace       -- Generate an interlaced (progressive) jpeg, input gboolean
#    no-subsample    -- Disable chroma subsample, input gboolean
#    strip           -- Strip all metadata from image, input gboolean
#    background      -- Background value, input VipsArrayDouble

##
# call-seq:
#    jpegsave_buffer() => buffer
#
# Save image to jpeg buffer.
#
#    buffer          -- Buffer to save to, output VipsBlob
#
# Options:
#    Q               -- Q factor, input gint
#    profile         -- ICC profile to embed, input gchararray
#    optimize-coding -- Compute optimal Huffman coding tables, input gboolean
#    interlace       -- Generate an interlaced (progressive) jpeg, input gboolean
#    no-subsample    -- Disable chroma subsample, input gboolean
#    strip           -- Strip all metadata from image, input gboolean
#    background      -- Background value, input VipsArrayDouble

##
# call-seq:
#    jpegsave_mime() => 
#
# Save image to jpeg mime.
#
# Options:
#    Q               -- Q factor, input gint
#    profile         -- ICC profile to embed, input gchararray
#    optimize-coding -- Compute optimal Huffman coding tables, input gboolean
#    interlace       -- Generate an interlaced (progressive) jpeg, input gboolean
#    no-subsample    -- Disable chroma subsample, input gboolean
#    strip           -- Strip all metadata from image, input gboolean
#    background      -- Background value, input VipsArrayDouble

##
# call-seq:
#    webpsave(filename) => 
#
# Save image to webp file.
#
#    filename        -- Filename to save to, input gchararray
#
# Options:
#    Q               -- Q factor, input gint
#    lossless        -- enable lossless compression, input gboolean
#    strip           -- Strip all metadata from image, input gboolean
#    background      -- Background value, input VipsArrayDouble

##
# call-seq:
#    webpsave_buffer() => buffer
#
# Save image to webp buffer.
#
#    buffer          -- Buffer to save to, output VipsBlob
#
# Options:
#    Q               -- Q factor, input gint
#    lossless        -- enable lossless compression, input gboolean
#    strip           -- Strip all metadata from image, input gboolean
#    background      -- Background value, input VipsArrayDouble

##
# call-seq:
#    tiffsave(filename) => 
#
# Save image to tiff file.
#
#    filename        -- Filename to save to, input gchararray
#
# Options:
#    compression     -- Compression for this file, input VipsForeignTiffCompression
#    Q               -- Q factor, input gint
#    predictor       -- Compression prediction, input VipsForeignTiffPredictor
#    profile         -- ICC profile to embed, input gchararray
#    tile            -- Write a tiled tiff, input gboolean
#    tile-width      -- Tile width in pixels, input gint
#    tile-height     -- Tile height in pixels, input gint
#    pyramid         -- Write a pyramidal tiff, input gboolean
#    squash          -- Squash images down to 1 bit, input gboolean
#    resunit         -- Resolution unit, input VipsForeignTiffResunit
#    xres            -- Horizontal resolution in pixels/mm, input gdouble
#    yres            -- Vertical resolution in pixels/mm, input gdouble
#    bigtiff         -- Write a bigtiff image, input gboolean
#    strip           -- Strip all metadata from image, input gboolean
#    background      -- Background value, input VipsArrayDouble

##
# call-seq:
#    fitssave(filename) => 
#
# Save image to fits file.
#
#    filename        -- Filename to save to, input gchararray
#
# Options:
#    strip           -- Strip all metadata from image, input gboolean
#    background      -- Background value, input VipsArrayDouble

##
# call-seq:
#    shrink(xshrink, yshrink) => out
#
# Shrink an image.
#
#    xshrink         -- Horizontal shrink factor, input gdouble
#    yshrink         -- Vertical shrink factor, input gdouble
#
#    out             -- Output image, output VipsImage

##
# call-seq:
#    quadratic(coeff) => out
#
# Resample an image with a quadratic transform.
#
#    coeff           -- Coefficient matrix, input VipsImage
#
#    out             -- Output image, output VipsImage
#
# Options:
#    interpolate     -- Interpolate values with this, input VipsInterpolate

##
# call-seq:
#    affine(matrix) => out
#
# Affine transform of an image.
#
#    matrix          -- Transformation matrix, input VipsArrayDouble
#
#    out             -- Output image, output VipsImage
#
# Options:
#    interpolate     -- Interpolate pixels with this, input VipsInterpolate
#    oarea           -- Area of output to generate, input VipsArrayInt
#    odx             -- Horizontal output displacement, input gdouble
#    ody             -- Vertical output displacement, input gdouble
#    idx             -- Horizontal input displacement, input gdouble
#    idy             -- Vertical input displacement, input gdouble

##
# call-seq:
#    similarity() => out
#
# Similarity transform of an image.
#
#    out             -- Output image, output VipsImage
#
# Options:
#    interpolate     -- Interpolate pixels with this, input VipsInterpolate
#    scale           -- Scale by this factor, input gdouble
#    angle           -- Rotate anticlockwise by this many degrees, input gdouble
#    odx             -- Horizontal output displacement, input gdouble
#    ody             -- Vertical output displacement, input gdouble
#    idx             -- Horizontal input displacement, input gdouble
#    idy             -- Vertical input displacement, input gdouble

##
# call-seq:
#    resize(scale) => out
#
# Resize an image.
#
#    scale           -- Scale image by this factor, input gdouble
#
#    out             -- Output image, output VipsImage
#
# Options:
#    interpolate     -- Interpolate pixels with this, input VipsInterpolate
#    idx             -- Horizontal input displacement, input gdouble
#    idy             -- Vertical input displacement, input gdouble

##
# call-seq:
#    colourspace(space) => out
#
# Convert to a new colourspace.
#
#    space           -- Destination colour space, input VipsInterpretation
#
#    out             -- Output image, output VipsImage
#
# Options:
#    source-space    -- Source colour space, input VipsInterpretation

##
# call-seq:
#    colourspace(space) => out
#
# Convert to a new colourspace.
#
#    space           -- Destination colour space, input VipsInterpretation
#
#    out             -- Output image, output VipsImage
#
# Options:
#    source-space    -- Source colour space, input VipsInterpretation

##
# call-seq:
#    Lab2XYZ() => out
#
# Transform cielab to xyz.
#
#    out             -- Output image, output VipsImage
#
# Options:
#    temp            -- Colour temperature, input VipsArrayDouble

##
# call-seq:
#    XYZ2Lab() => out
#
# Transform xyz to lab.
#
#    out             -- Output image, output VipsImage
#
# Options:
#    temp            -- Colour temperature, input VipsArrayDouble

##
# call-seq:
#    Lab2LCh() => out
#
# Transform lab to lch.
#
#    out             -- Output image, output VipsImage

##
# call-seq:
#    LCh2Lab() => out
#
# Transform lch to lab.
#
#    out             -- Output image, output VipsImage

##
# call-seq:
#    LCh2CMC() => out
#
# Transform lch to cmc.
#
#    out             -- Output image, output VipsImage

##
# call-seq:
#    CMC2LCh() => out
#
# Transform lch to cmc.
#
#    out             -- Output image, output VipsImage

##
# call-seq:
#    XYZ2Yxy() => out
#
# Transform xyz to yxy.
#
#    out             -- Output image, output VipsImage

##
# call-seq:
#    Yxy2XYZ() => out
#
# Transform yxy to xyz.
#
#    out             -- Output image, output VipsImage

##
# call-seq:
#    scRGB2XYZ() => out
#
# Transform scrgb to xyz.
#
#    out             -- Output image, output VipsImage

##
# call-seq:
#    XYZ2scRGB() => out
#
# Transform xyz to scrgb.
#
#    out             -- Output image, output VipsImage

##
# call-seq:
#    LabQ2Lab() => out
#
# Unpack a labq image to float lab.
#
#    out             -- Output image, output VipsImage

##
# call-seq:
#    Lab2LabQ() => out
#
# Transform float lab to labq coding.
#
#    out             -- Output image, output VipsImage

##
# call-seq:
#    LabQ2LabS() => out
#
# Unpack a labq image to short lab.
#
#    out             -- Output image, output VipsImage

##
# call-seq:
#    LabS2LabQ() => out
#
# Transform short lab to labq coding.
#
#    out             -- Output image, output VipsImage

##
# call-seq:
#    LabS2Lab() => out
#
# Transform signed short lab to float.
#
#    out             -- Output image, output VipsImage

##
# call-seq:
#    Lab2LabS() => out
#
# Transform float lab to signed short.
#
#    out             -- Output image, output VipsImage

##
# call-seq:
#    rad2float() => out
#
# Unpack radiance coding to float rgb.
#
#    out             -- Output image, output VipsImage

##
# call-seq:
#    float2rad() => out
#
# Transform float rgb to radiance coding.
#
#    out             -- Output image, output VipsImage

##
# call-seq:
#    LabQ2sRGB() => out
#
# Unpack a labq image to short lab.
#
#    out             -- Output image, output VipsImage

##
# call-seq:
#    sRGB2scRGB() => out
#
# Convert an srgb image to scrgb.
#
#    out             -- Output image, output VipsImage

##
# call-seq:
#    scRGB2sRGB() => out
#
# Convert an scrgb image to srgb.
#
#    out             -- Output image, output VipsImage
#
# Options:
#    depth           -- Output device space depth in bits, input gint

##
# call-seq:
#    icc_import() => out
#
# Import from device with icc profile.
#
#    out             -- Output image, output VipsImage
#
# Options:
#    pcs             -- Set Profile Connection Space, input VipsPCS
#    intent          -- Rendering intent, input VipsIntent
#    embedded        -- Use embedded input profile, if available, input gboolean
#    input-profile   -- Filename to load input profile from, input gchararray

##
# call-seq:
#    icc_export() => out
#
# Output to device with icc profile.
#
#    out             -- Output image, output VipsImage
#
# Options:
#    pcs             -- Set Profile Connection Space, input VipsPCS
#    intent          -- Rendering intent, input VipsIntent
#    output-profile  -- Filename to load output profile from, input gchararray
#    depth           -- Output device space depth in bits, input gint

##
# call-seq:
#    icc_transform(output-profile) => out
#
# Transform between devices with icc profiles.
#
#    output-profile  -- Filename to load output profile from, input gchararray
#
#    out             -- Output image, output VipsImage
#
# Options:
#    pcs             -- Set Profile Connection Space, input VipsPCS
#    intent          -- Rendering intent, input VipsIntent
#    embedded        -- Use embedded input profile, if available, input gboolean
#    input-profile   -- Filename to load input profile from, input gchararray
#    depth           -- Output device space depth in bits, input gint

##
# call-seq:
#    dE76(right) => out
#
# Calculate de76.
#
#    right           -- Right-hand input image, input VipsImage
#
#    out             -- Output image, output VipsImage

##
# call-seq:
#    dE00(right) => out
#
# Calculate de00.
#
#    right           -- Right-hand input image, input VipsImage
#
#    out             -- Output image, output VipsImage

##
# call-seq:
#    dECMC(right) => out
#
# Calculate decmc.
#
#    right           -- Right-hand input image, input VipsImage
#
#    out             -- Output image, output VipsImage

##
# call-seq:
#    maplut(lut) => out
#
# Map an image though a lut.
#
#    lut             -- Look-up table image, input VipsImage
#
#    out             -- Output image, output VipsImage
#
# Options:
#    band            -- apply one-band lut to this band of in, input gint

##
# call-seq:
#    percent(percent) => threshold
#
# Find threshold for percent of pixels.
#
#    percent         -- Percent of pixels, input gdouble
#
#    threshold       -- Threshold above which lie percent of pixels, output gint

##
# call-seq:
#    stdif(width, height) => out
#
# Statistical difference.
#
#    width           -- Window width in pixels, input gint
#    height          -- Window height in pixels, input gint
#
#    out             -- Output image, output VipsImage
#
# Options:
#    a               -- Weight of new mean, input gdouble
#    s0              -- New deviation, input gdouble
#    b               -- Weight of new deviation, input gdouble
#    m0              -- New mean, input gdouble

##
# call-seq:
#    hist_cum() => out
#
# Form cumulative histogram.
#
#    out             -- Output image, output VipsImage

##
# call-seq:
#    hist_match(ref) => out
#
# Match two histograms.
#
#    ref             -- Reference histogram, input VipsImage
#
#    out             -- Output image, output VipsImage

##
# call-seq:
#    hist_norm() => out
#
# Normalise histogram.
#
#    out             -- Output image, output VipsImage

##
# call-seq:
#    hist_equal() => out
#
# Histogram equalisation.
#
#    out             -- Output image, output VipsImage
#
# Options:
#    band            -- Equalise with this band, input gint

##
# call-seq:
#    hist_plot() => out
#
# Plot histogram.
#
#    out             -- Output image, output VipsImage

##
# call-seq:
#    hist_local(width, height) => out
#
# Local histogram equalisation.
#
#    width           -- Window width in pixels, input gint
#    height          -- Window height in pixels, input gint
#
#    out             -- Output image, output VipsImage

##
# call-seq:
#    hist_ismonotonic() => monotonic
#
# Test for monotonicity.
#
#    monotonic       -- true if in is monotonic, output gboolean

##
# call-seq:
#    conv(mask) => out
#
# Convolution operation.
#
#    mask            -- Input matrix image, input VipsImage
#
#    out             -- Output image, output VipsImage
#
# Options:
#    precision       -- Convolve with this precision, input VipsPrecision
#    layers          -- Use this many layers in approximation, input gint
#    cluster         -- Cluster lines closer than this in approximation, input gint

##
# call-seq:
#    compass(mask) => out
#
# Convolve with rotating mask.
#
#    mask            -- Input matrix image, input VipsImage
#
#    out             -- Output image, output VipsImage
#
# Options:
#    times           -- Rotate and convolve this many times, input gint
#    angle           -- Rotate mask by this much between convolutions, input VipsAngle45
#    combine         -- Combine convolution results like this, input VipsCombine
#    precision       -- Convolve with this precision, input VipsPrecision
#    layers          -- Use this many layers in approximation, input gint
#    cluster         -- Cluster lines closer than this in approximation, input gint

##
# call-seq:
#    convsep(mask) => out
#
# Seperable convolution operation.
#
#    mask            -- Input matrix image, input VipsImage
#
#    out             -- Output image, output VipsImage
#
# Options:
#    precision       -- Convolve with this precision, input VipsPrecision
#    layers          -- Use this many layers in approximation, input gint
#    cluster         -- Cluster lines closer than this in approximation, input gint

##
# call-seq:
#    fastcor(ref) => out
#
# Fast correlation.
#
#    ref             -- Input reference image, input VipsImage
#
#    out             -- Output image, output VipsImage

##
# call-seq:
#    spcor(ref) => out
#
# Spatial correlation.
#
#    ref             -- Input reference image, input VipsImage
#
#    out             -- Output image, output VipsImage

##
# call-seq:
#    sharpen() => out
#
# Unsharp masking for print.
#
#    out             -- Output image, output VipsImage
#
# Options:
#    radius          -- Mask radius, input gint
#    x1              -- Flat/jaggy threshold, input gdouble
#    y2              -- Maximum brightening, input gdouble
#    y3              -- Maximum darkening, input gdouble
#    m1              -- Slope for flat areas, input gdouble
#    m2              -- Slope for jaggy areas, input gdouble

##
# call-seq:
#    gaussblur(sigma) => out
#
# Gaussian blur.
#
#    sigma           -- Sigma of Gaussian, input gdouble
#
#    out             -- Output image, output VipsImage
#
# Options:
#    min-ampl        -- Minimum amplitude of Gaussian, input gdouble
#    precision       -- Convolve with this precision, input VipsPrecision

##
# call-seq:
#    fwfft() => out
#
# Forward fft.
#
#    out             -- Output image, output VipsImage

##
# call-seq:
#    invfft() => out
#
# Inverse fft.
#
#    out             -- Output image, output VipsImage
#
# Options:
#    real            -- Output only the real part of the transform, input gboolean

##
# call-seq:
#    freqmult(mask) => out
#
# Frequency-domain filtering.
#
#    mask            -- Input mask image, input VipsImage
#
#    out             -- Output image, output VipsImage

##
# call-seq:
#    spectrum() => out
#
# Make displayable power spectrum.
#
#    out             -- Output image, output VipsImage

##
# call-seq:
#    phasecor(in2) => out
#
# Calculate phase correlation.
#
#    in2             -- Second input image, input VipsImage
#
#    out             -- Output image, output VipsImage

##
# call-seq:
#    morph(mask, morph) => out
#
# Morphology operation.
#
#    mask            -- Input matrix image, input VipsImage
#    morph           -- Morphological operation to perform, input VipsOperationMorphology
#
#    out             -- Output image, output VipsImage

##
# call-seq:
#    rank(width, height, index) => out
#
# Rank filter.
#
#    width           -- Window width in pixels, input gint
#    height          -- Window height in pixels, input gint
#    index           -- Select pixel at index, input gint
#
#    out             -- Output image, output VipsImage

##
# call-seq:
#    countlines(direction) => nolines
#
# Count lines in an image.
#
#    direction       -- Countlines left-right or up-down, input VipsDirection
#
#    nolines         -- Number of lines, output gdouble

##
# call-seq:
#    labelregions() => mask
#
# Label regions in an image.
#
#    mask            -- Mask of region labels, output VipsImage
#
# Output options:
#    segments        -- Number of discrete contigious regions, output gint

##
# call-seq:
#    draw_rect(ink, left, top, width, height) => 
#
# Paint a rectangle on an image.
#
#    ink             -- Colour for pixels, input VipsArrayDouble
#    left            -- Rect to fill, input gint
#    top             -- Rect to fill, input gint
#    width           -- Rect to fill, input gint
#    height          -- Rect to fill, input gint
#
# Options:
#    fill            -- Draw a solid object, input gboolean

##
# call-seq:
#    draw_mask(ink, mask, x, y) => 
#
# Draw a mask on an image.
#
#    ink             -- Colour for pixels, input VipsArrayDouble
#    mask            -- Mask of pixels to draw, input VipsImage
#    x               -- Draw mask here, input gint
#    y               -- Draw mask here, input gint

##
# call-seq:
#    draw_line(ink, x1, y1, x2, y2) => 
#
# Draw a draw_line on an image.
#
#    ink             -- Colour for pixels, input VipsArrayDouble
#    x1              -- Start of draw_line, input gint
#    y1              -- Start of draw_line, input gint
#    x2              -- End of draw_line, input gint
#    y2              -- End of draw_line, input gint

##
# call-seq:
#    draw_circle(ink, cx, cy, radius) => 
#
# Draw a draw_circle on an image.
#
#    ink             -- Colour for pixels, input VipsArrayDouble
#    cx              -- Centre of draw_circle, input gint
#    cy              -- Centre of draw_circle, input gint
#    radius          -- Radius in pixels, input gint
#
# Options:
#    fill            -- Draw a solid object, input gboolean

##
# call-seq:
#    draw_flood(ink, x, y) => 
#
# Flood-fill an area.
#
#    ink             -- Colour for pixels, input VipsArrayDouble
#    x               -- DrawFlood start point, input gint
#    y               -- DrawFlood start point, input gint
#
# Options:
#    test            -- Test pixels in this image, input VipsImage
#    equal           -- DrawFlood while equal to edge, input gboolean
#
# Output options:
#    left            -- Left edge of modified area, output gint
#    top             -- top edge of modified area, output gint
#    width           -- width of modified area, output gint
#    height          -- height of modified area, output gint

##
# call-seq:
#    draw_image(sub, x, y) => 
#
# Paint an image into another image.
#
#    sub             -- Sub-image to insert into main image, input VipsImage
#    x               -- Draw image here, input gint
#    y               -- Draw image here, input gint
#
# Options:
#    mode            -- Combining mode, input VipsCombineMode

##
# call-seq:
#    draw_smudge(left, top, width, height) => 
#
# Blur a rectangle on an image.
#
#    left            -- Rect to fill, input gint
#    top             -- Rect to fill, input gint
#    width           -- Rect to fill, input gint
#    height          -- Rect to fill, input gint

##
# call-seq:
#    merge(sec, direction, dx, dy) => out
#
# Merge two images.
#
#    sec             -- Secondary image, input VipsImage
#    direction       -- Horizontal or vertcial merge, input VipsDirection
#    dx              -- Horizontal displacement from sec to ref, input gint
#    dy              -- Vertical displacement from sec to ref, input gint
#
#    out             -- Output image, output VipsImage
#
# Options:
#    mblend          -- Maximum blend size, input gint

##
# call-seq:
#    mosaic(sec, direction, xref, yref, xsec, ysec) => out
#
# Mosaic two images.
#
#    sec             -- Secondary image, input VipsImage
#    direction       -- Horizontal or vertcial mosaic, input VipsDirection
#    xref            -- Position of reference tie-point, input gint
#    yref            -- Position of reference tie-point, input gint
#    xsec            -- Position of secondary tie-point, input gint
#    ysec            -- Position of secondary tie-point, input gint
#
#    out             -- Output image, output VipsImage
#
# Options:
#    hwindow         -- Half window size, input gint
#    harea           -- Half area size, input gint
#    mblend          -- Maximum blend size, input gint
#    bandno          -- Band to search for features on, input gint
#
# Output options:
#    dx0             -- Detected integer offset, output gint
#    dy0             -- Detected integer offset, output gint
#    scale1          -- Detected scale, output gdouble
#    angle1          -- Detected rotation, output gdouble
#    dx1             -- Detected first-order displacement, output gdouble
#    dy1             -- Detected first-order displacement, output gdouble

##
# call-seq:
#    mosaic1(sec, direction, xr1, yr1, xs1, ys1, xr2, yr2, xs2, ys2) => out
#
# First-order mosaic of two images.
#
#    sec             -- Secondary image, input VipsImage
#    direction       -- Horizontal or vertcial mosaic, input VipsDirection
#    xr1             -- Position of first reference tie-point, input gint
#    yr1             -- Position of first reference tie-point, input gint
#    xs1             -- Position of first secondary tie-point, input gint
#    ys1             -- Position of first secondary tie-point, input gint
#    xr2             -- Position of second reference tie-point, input gint
#    yr2             -- Position of second reference tie-point, input gint
#    xs2             -- Position of second secondary tie-point, input gint
#    ys2             -- Position of second secondary tie-point, input gint
#
#    out             -- Output image, output VipsImage
#
# Options:
#    hwindow         -- Half window size, input gint
#    harea           -- Half area size, input gint
#    search          -- Search to improve tie-points, input gboolean
#    interpolate     -- Interpolate pixels with this, input VipsInterpolate
#    mblend          -- Maximum blend size, input gint
#    bandno          -- Band to search for features on, input gint

##
# call-seq:
#    match(sec, xr1, yr1, xs1, ys1, xr2, yr2, xs2, ys2) => out
#
# First-order match of two images.
#
#    sec             -- Secondary image, input VipsImage
#    xr1             -- Position of first reference tie-point, input gint
#    yr1             -- Position of first reference tie-point, input gint
#    xs1             -- Position of first secondary tie-point, input gint
#    ys1             -- Position of first secondary tie-point, input gint
#    xr2             -- Position of second reference tie-point, input gint
#    yr2             -- Position of second reference tie-point, input gint
#    xs2             -- Position of second secondary tie-point, input gint
#    ys2             -- Position of second secondary tie-point, input gint
#
#    out             -- Output image, output VipsImage
#
# Options:
#    hwindow         -- Half window size, input gint
#    harea           -- Half area size, input gint
#    search          -- Search to improve tie-points, input gboolean
#    interpolate     -- Interpolate pixels with this, input VipsInterpolate

##
# call-seq:
#    globalbalance() => out
#
# Global balance an image mosaic.
#
#    out             -- Output image, output VipsImage
#
# Options:
#    gamma           -- Image gamma, input gdouble
#    int-output      -- Integer output, input gboolean

